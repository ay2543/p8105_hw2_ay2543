---
title: "HW2"
output: github_document
date: "2022-09-29"
---

# Problem 1

Before we do anything, load the `tidyverse` package.

```{r, message = FALSE}
library(tidyverse)
```

Now we can get started!

First, load the data.
```{r, message = FALSE}
# Read data and clean names
transit = read_csv("NYC_Transit_Subway_Entrance_And_Exit_Data.csv", 
                   col_types = cols(Route8 = "c", Route9 = "c", Route10 = "c", Route11 = "c"))  %>% 
  janitor::clean_names()
  
# Check column names of imported data
colnames(transit)

```

Next we do some cleaning.
```{r}
transit_clean = transit %>% 
 select(line:entry, vending, ada) %>% 
  mutate(entry = ifelse(entry == "YES", TRUE, FALSE))

```

transit_clean is a `r nrow(transit_clean)`x`r ncol(transit_clean)` dataset with the following variables:

* ``r colnames(transit_clean)``

However, there are still many separate variables in transit_clean that could be combined to be tidier.

Here are some other details about the dataset.

```{r}
# Number of distinct stations
nrow(distinct(transit_clean, station_name))
```

There are **`r nrow(distinct(transit_clean, station_name))`** distinct stations.

```{r}
# ADA-compliant stations

transit_clean %>% filter(ada == TRUE) %>% nrow()

```
**`r transit_clean %>% filter(ada == TRUE) %>% nrow()`** stations are ADA-compliant.

```{r}
# Proportion of station entrances/exits without vending that allow entry
transit_clean %>% 
  filter(vending == "NO") %>% 
  pull(entry) %>% 
  mean()

```
**`r transit_clean %>% filter(vending == "NO") %>% pull(entry) %>% mean()*100`%** of station entrances/exits without vending allow entry.


Let's make transit_clean tidy by reformatting the route number and name with `pivot_longer`, and then filter by distinct stations that serve the A train and how many of those are ADA compliant.

```{r}
transit_tidy = 
  transit_clean %>% 
  pivot_longer(route1:route11, 
               names_to = "route_number",
               values_to = "route_name") 

transit_tidy %>% 
  filter(route_name == "A") %>% 
  select(station_name, line) %>% 
  distinct

transit_tidy %>% 
  filter(route_name == "A", ada == "TRUE") %>% 
  select(station_name, line) %>% 
  distinct
```
**`r transit_tidy %>% filter(route_name == "A") %>% select(station_name, line) %>% distinct %>% count()`** distinct stations serve the A train, and **`r transit_tidy %>% filter(route_name == "A", ada == "TRUE") %>% select(station_name, line) %>% distinct %>% count()`** distinct stations serve the A train and are ADA compliant.

# Problem 2

First, load the additional required packages for this problem.
```{r, message = FALSE}
library(readxl)
```



Now, I can load the Mr. Trash Wheel sheet within the Trash Wheel Collection Excel file. I specified a range that excludes the figures and columns containing notes, as well as omitting the final row indicating a grand total. 

After cleaning the variable names with `clean_names`, I renamed the weight_tons and volume_cubic_yards variables to be shorter. 
I filtered away observations that did not include dumpster-specific data with `filter`, and used `mutate` to round the number of sports balls to the nearest integer, and add a variable indicating this dataset was from the Mr. Trash Wheel sheet.
```{r}
mrtrash = read_excel("./data/Trash Wheel Collection Data.xlsx", 
                   sheet = "Mr. Trash Wheel", 
                   range = "A2:N549") %>% 
  janitor::clean_names() %>% 
  rename(weight = weight_tons,
                volume = volume_cubic_yards) %>% 
  filter(!is.na(dumpster)) %>% 
  mutate(sports_balls = as.integer(sports_balls),
         year = as.double(year),
         sheet = "Mr. Trash Wheel")
```

Then I did the same with the Professor Trash Wheel sheet:

```{r}
proftrash = read_excel("./data/Trash Wheel Collection Data.xlsx", 
                   sheet = "Professor Trash Wheel", 
                   range = "A2:M96") %>% 
  janitor::clean_names() %>% 
  rename(weight = weight_tons,
                volume = volume_cubic_yards) %>% 
  filter(!is.na(dumpster)) %>% 
  mutate(sheet = "Professor Trash Wheel")
```

Now I can use a `full_join` to combine the datasets into one dataset called trash.
```{r, message = FALSE}
trash = full_join(mrtrash, proftrash)
```

The combined data set consists of **`r nrow(trash)` observations and `r ncol(trash)` variables**.
The included variables are *`r colnames(trash)`*, with the last variable being an indicator of the original sheet the observation was taken from.

The total weight of trash collected by Professor Trash Wheel was **`r sum(proftrash$weight)` tons**.

The total number of sports balls collected by Mr. Trash Wheel in 2020 was **`r mrtrash %>% filter(year == 2020) %>% pull(sports_balls) %>% sum()` tons**.


# Problem 3

First, I loaded the pols dataset, then used `separate()` to break up the mon variable into year, month and day. Then I used `lubridate::month` to replace the month number with the month name. I then used `pivot_longer` to create a president variable taking values from prez_dem and prez_gop. Finally, I removed the day variable with `select`.

```{r, message = FALSE}
pols = read_csv("./data/pols-month.csv") %>% 
  separate(mon, into = c("year", "month", "day"), sep = "-") %>% 
  mutate(month = lubridate::month(as.numeric(month), label = TRUE, abbr = FALSE),
         year = as.double(year)) %>% 
  pivot_longer(c(prez_dem, prez_gop),
               names_to = "president",
               names_prefix = "prez_",
               values_to = "president_value") %>% 
  select(-day)

```


Second, clean the data in snp.csv using a similar process to the above. For consistency across datasets, arrange according to year and month, and organize so that year and month are the leading columns.
I cleaned the snp dataset in a similar process as above. Since the date variable was in a mm/dd/yy format, I first used `lubridate::mdy` to reformat it into the standard yyyy-mm-dd format, then I separated it into year, month and day variables with `select`, and changed the month into the full name and removed the day variable.

```{r, message = FALSE}

snp = read_csv("./data/snp.csv") %>% 
   mutate(date = lubridate::mdy(date)) %>% 
  separate(date, into = c("year", "month", "day"), sep = "-") %>% 
  mutate(month = lubridate::month(as.numeric(month), label = TRUE, abbr = FALSE),
         year = as.double(year)) %>% 
 select(-day)

  

```


Next, I tidied the unemployment data by using `pivot_longer` to create a single month variable instead of having one variable per month, then cleaned the names with `janitor::clean_names()` to be consistent with the previous datasets. I changed the month variable from the abbreviated month names to the full month names by using `factor` with the abbreviations (month.abb) as the levels and renaming the labels to the full month names (month.name).
```{r, message = FALSE}
unemployment = read_csv("./data/unemployment.csv") %>% 
  pivot_longer(Jan:Dec,
               names_to = "month",
               values_to = "unemployment") %>% 
  janitor::clean_names() %>% 
  mutate(month = factor(month, levels = month.abb, labels = month.name, ordered = TRUE),
         year = as.double(year))
```


Join the datasets by merging snp into pols, and merging unemployment into the result.

Finally, I used `left_join` to merge snp into pols, and then unemployment into the earlier merge.
```{r}
merge_df = left_join(pols, snp) %>% 
  left_join(., unemployment)
```


Write a short paragraph about these datasets. Explain briefly what each dataset contained, and describe the resulting dataset (e.g. give the dimension, range of years, and names of key variables).

The pols dataset contained **`r nrow(pols)`** observations and **`r ncol(pols)`** variables. The included variables were *`r colnames(pols)`*.

The snp dataset contained **`r nrow(snp)`** observations and **`r ncol(snp)`** variables. The included variables were *`r colnames(snp)`*.

The unemployment dataset contained **`r nrow(unemployment)`** observations and **`r ncol(unemployment)`** variables. The included variables were *`r colnames(unemployment)`*.

The resulting merge_df dataset has a dimension of **`r nrow(merge_df)` observations x `r ncol(merge_df)` variables**. The range of years was `r range(merge_df$year)`, and the variable names are *`r colnames(merge_df)`*. 









